---
title: Resolve Greptile comments in your IDE
description: 'Retrieve and resolve Greptile review comments automatically with coding agents'
keywords: 'comment resolution, automated fixes, code review, AI assistance'
---

Enable coding agents to automatically retrieve and resolve Greptile review comments, reducing manual review follow-up work.

## Overview

Coding agents can access Greptile review comments through the MCP server to understand issues and apply fixes automatically. This creates a feedback loop where review insights improve code quality in real-time.

## Retrieving Comments

### Get PR Comments

Retrieve all comments for a specific pull request:

```javascript
list_merge_request_comments({
  name: "owner/repo",
  remote: "github",
  defaultBranch: "main",
  prNumber: 123,
  greptileGenerated: true,
  addressed: false
})
```

**Response includes:**
- Comment text and location (file, line numbers)
- Addressed status
- Linked custom context (patterns that triggered the comment)
- Creation timestamp

### Search Issue-Specific Comments

Find comments about specific code issues across repositories:

```javascript
search_greptile_comments({
  query: "memory leak",
  limit: 10,
  includeAddressed: false
})
```

**Use cases:**
- Find all instances of a specific issue type
- Learn from past review feedback
- Identify recurring problems across codebases

## Automated Resolution Workflows

### Basic Resolution Flow

<Steps>
    <Step title="Retrieve Comments">
        Coding agent gets unaddressed comments for current PR or file.
    </Step>
    <Step title="Analyze Context">
        Agent reads comment details, linked patterns, and surrounding code.
    </Step>
    <Step title="Apply Fixes">
        Agent generates and applies code changes to address the issue.
    </Step>
    <Step title="Verify Resolution">
        Agent checks that the fix addresses the original concern.
    </Step>
</Steps>

### Comment Analysis

**Extract Actionable Information:**
```javascript
function analyzeComment(comment) {
  return {
    issueType: categorizeIssue(comment.body),
    location: {
      file: comment.filePath,
      startLine: comment.lineStart,
      endLine: comment.lineEnd
    },
    severity: assessSeverity(comment.body),
    suggestedFix: extractSuggestion(comment.body),
    relatedPattern: comment.linkedMemory?.body
  };
}
```

**Issue Categorization:**
- **Logic errors:** Incorrect behavior, edge cases
- **Performance issues:** Inefficient algorithms, memory leaks
- **Security vulnerabilities:** Input validation, authentication
- **Style violations:** Formatting, naming conventions
- **Architecture concerns:** Design patterns, coupling

### Fix Application Strategies

**Direct Code Replacement:**
```javascript
async function applyDirectFix(comment, codeContent) {
  const analysis = analyzeComment(comment);

  if (analysis.suggestedFix && analysis.location) {
    // Apply suggested fix to specified lines
    const fixedCode = replaceLines(
      codeContent,
      analysis.location.startLine,
      analysis.location.endLine,
      analysis.suggestedFix
    );

    return {
      success: true,
      changes: fixedCode,
      method: 'direct_replacement'
    };
  }

  return { success: false, reason: 'no_direct_suggestion' };
}
```

**Pattern-Based Fixes:**
```javascript
async function applyPatternFix(comment, codeContent) {
  if (!comment.linkedMemory) return { success: false };

  const pattern = comment.linkedMemory.body;
  const violation = identifyPatternViolation(codeContent, pattern);

  if (violation) {
    const fixedCode = applyPattern(codeContent, pattern, violation);
    return {
      success: true,
      changes: fixedCode,
      method: 'pattern_application',
      pattern: pattern
    };
  }

  return { success: false, reason: 'pattern_not_applicable' };
}
```

**AI-Generated Fixes:**
```javascript
async function generateFix(comment, codeContent, context) {
  const prompt = `
Fix this code issue:
Issue: ${comment.body}
File: ${comment.filePath}
Lines ${comment.lineStart}-${comment.lineEnd}:
${extractLines(codeContent, comment.lineStart, comment.lineEnd)}

Related pattern: ${comment.linkedMemory?.body || 'None'}
Context: ${context}
`;

  const fix = await aiCodeGeneration(prompt);
  return {
    success: true,
    changes: fix,
    method: 'ai_generated'
  };
}
```

## Integration Examples

### VS Code Extension

```javascript
// Extension activation
async function resolveGreptileComments(workspaceFolder) {
  const currentBranch = await git.getCurrentBranch();
  const prNumber = await git.getPRNumber(currentBranch);

  if (!prNumber) return;

  // Get unaddressed comments
  const comments = await mcpClient.call('list_merge_request_comments', {
    name: workspaceFolder.name,
    remote: 'github',
    defaultBranch: 'main',
    prNumber: prNumber,
    greptileGenerated: true,
    addressed: false
  });

  // Process each comment
  for (const comment of comments.comments) {
    const success = await attemptAutoFix(comment);

    if (success) {
      vscode.window.showInformationMessage(
        `Auto-fixed: ${comment.body.substring(0, 50)}...`
      );
    } else {
      // Show as code action for manual review
      registerCodeAction(comment);
    }
  }
}
```

### Pre-commit Hook

```javascript
#!/usr/bin/env node
// pre-commit-review-check.js

async function checkForUnaddressedComments() {
  const changedFiles = await git.getChangedFiles();

  // Get comments for changed files
  const allComments = await mcpClient.call('search_greptile_comments', {
    query: changedFiles.join(' OR '),
    limit: 50,
    includeAddressed: false
  });

  const relevantComments = allComments.comments.filter(comment =>
    changedFiles.includes(comment.filePath)
  );

  if (relevantComments.length > 0) {
    console.log('Unaddressed review comments found:');
    relevantComments.forEach(comment => {
      console.log(`- ${comment.filePath}:${comment.lineStart}: ${comment.body}`);
    });

    // Attempt auto-fixes
    const fixResults = await Promise.all(
      relevantComments.map(comment => attemptAutoFix(comment))
    );

    const unfixedComments = relevantComments.filter((_, index) =>
      !fixResults[index].success
    );

    if (unfixedComments.length > 0) {
      console.log(`${unfixedComments.length} comments require manual attention`);
      process.exit(1);
    }
  }
}

checkForUnaddressedComments().catch(console.error);
```

### CI/CD Integration

```yaml
# .github/workflows/auto-fix-reviews.yml
name: Auto-fix Review Comments

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Auto-fix Review Comments
        env:
          GREPTILE_API_KEY: ${{ secrets.GREPTILE_API_KEY }}
        run: |
          # Get PR comments
          node -e "
          const { execSync } = require('child_process');
          const prNumber = process.env.GITHUB_REF.split('/')[2];

          // Run auto-fix script
          execSync('node scripts/auto-fix-comments.js ' + prNumber, {stdio: 'inherit'});
          "

      - name: Commit fixes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add .
          git diff --staged --quiet || git commit -m "Auto-fix review comments"
          git push
```

## Comment Resolution Patterns

### Security Issues

**Input Validation:**
```javascript
// Comment: "Missing input validation for user ID"
// Before:
function getUserData(userId) {
  return database.users.find(userId);
}

// Auto-fix:
function getUserData(userId) {
  if (!userId || typeof userId !== 'string') {
    throw new Error('Invalid user ID');
  }
  return database.users.find(userId);
}
```

### Performance Issues

**Inefficient Queries:**
```javascript
// Comment: "N+1 query problem - use joins or batch loading"
// Before:
const users = await User.findAll();
const profiles = await Promise.all(
  users.map(user => Profile.findByUserId(user.id))
);

// Auto-fix:
const users = await User.findAll({
  include: [Profile]
});
```

### Style Violations

**Naming Conventions:**
```javascript
// Comment: "Use camelCase for variable names"
// Before:
const user_data = fetchUserInfo();
const is_valid_user = checkUser(user_data);

// Auto-fix:
const userData = fetchUserInfo();
const isValidUser = checkUser(userData);
```

## Advanced Features

### Context-Aware Fixes

```javascript
async function getFixContext(comment) {
  // Get PR context
  const pr = await mcpClient.call('get_merge_request', {
    name: comment.mergeRequest.repository.name,
    remote: 'github',
    defaultBranch: 'main',
    prNumber: comment.mergeRequest.prNumber
  });

  // Get related patterns
  const patterns = await mcpClient.call('search_custom_context', {
    query: extractKeywords(comment.body),
    limit: 5
  });

  // Get similar resolved comments
  const similarComments = await mcpClient.call('search_greptile_comments', {
    query: comment.body.substring(0, 50),
    limit: 10,
    includeAddressed: true
  });

  return {
    prContext: pr.mergeRequest,
    relatedPatterns: patterns.customContexts,
    similarResolutions: similarComments.comments.filter(c => c.addressed)
  };
}
```

### Learning from Resolutions

```javascript
async function trackResolutionSuccess(comment, fix, outcome) {
  // Store resolution data for learning
  const resolutionData = {
    commentId: comment.id,
    issueType: categorizeIssue(comment.body),
    fixMethod: fix.method,
    success: outcome.success,
    timeToFix: outcome.timeToFix,
    humanReviewRequired: outcome.needsReview
  };

  // Use data to improve future auto-fixes
  await updateFixStrategies(resolutionData);
}
```

## Best Practices

### Fix Verification

- **Syntax checking:** Ensure fixes don't break code syntax
- **Test execution:** Run relevant tests after applying fixes
- **Review integration:** Mark comments as addressed only after verification
- **Rollback capability:** Provide undo functionality for problematic fixes

### Human Oversight

- **Confidence scoring:** Only auto-apply high-confidence fixes
- **Review queuing:** Queue uncertain fixes for human review
- **Explanation logging:** Document what changes were made and why
- **Approval workflows:** Require human approval for critical file changes
