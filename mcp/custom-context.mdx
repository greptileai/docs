---
title: Access Custom Context in your IDE
description: 'Use organization coding patterns with AI assistants through Greptile MCP server'
keywords: 'custom context, coding patterns, organization standards, AI coding assistance'
---

Greptile learns your team's coding standards and best practices by reading human engineer's comments in PRs.

In this guide, we'll use the Greptile MCP server to allow your coding agent or IDE to access these learnings and use them during code generation.

<Note>
**Prerequisites**: First [set up the MCP server in your IDE](/mcp/setup-ides), then follow the workflows below.
</Note>

## Overview

Once configured, you will be able to:
- Browse your organization's coding patterns and standards
- Get specific guidance for the type of code being written
- Apply consistent patterns during code generation
- Create new patterns from review feedback

...inside your IDE or coding agent.


## Discovering Patterns

### Get Organization Patterns

<Steps>
    <Step title="Browse All Patterns">
        Ask Claude: "What custom context does my organization have?"

        Claude will show you all available patterns with details like:
        - Pattern type (custom instruction vs pattern)
        - Scope where it applies (file types, directories)
        - Usage statistics and related comments
    </Step>
    <Step title="Search by Topic">
        Use natural language to find specific patterns:
        - "Find coding patterns related to error handling"
        - "Show me security-related coding standards"
        - "What React patterns does my organization use?"
    </Step>
    <Step title="Get Pattern Details">
        For detailed information about a specific pattern:
        - "Tell me more about the async/await pattern"
        - "Show me examples of the input validation standard"
        - "Why do we have this authentication pattern?"
    </Step>
</Steps>

### Find Relevant Context

**Context by File Type:**
- "What patterns apply to TypeScript files?"
- "Show me Python-specific coding standards"
- "Are there any React component guidelines?"

**Context by Domain:**
- "What security patterns should I follow for authentication?"
- "Show me database-related coding standards"
- "Are there API design patterns I should use?"

## Using Patterns in Code

### Apply Context During Development

<Steps>
    <Step title="Load Patterns Before Coding">
        Before starting work on a new feature or file:
        - "Load all patterns relevant to authentication code"
        - "What coding standards should I follow for this React component?"
        - "Show me organization patterns for error handling"
    </Step>
    <Step title="Get Context-Specific Guidance">
        When writing specific types of code:
        - "I'm writing a REST API endpoint, what patterns should I follow?"
        - "What security patterns apply to user input validation?"
        - "How should I handle database connections based on our patterns?"
    </Step>
    <Step title="Validate Against Standards">
        Before committing code:
        - "Does this code follow our organization's patterns?"
        - "Are there any style violations in this component?"
        - "Check if my error handling matches our standards"
    </Step>
</Steps>

### Pattern-Guided Code Generation

**Start New Features:**
```
You: "I need to create a user authentication endpoint following our organization patterns"

Claude: Based on your organization's custom context, I can see you follow these patterns:
- Always validate input parameters using Joi schemas
- Use Result<T, E> for error handling
- Include rate limiting on authentication endpoints
- Log authentication attempts for security auditing

Let me create an endpoint that follows these standards...
```

**Refactor Existing Code:**
```
You: "Refactor this function to match our coding patterns"

Claude: I can see your organization emphasizes:
- Async/await over Promise.then()
- Functional programming patterns
- Comprehensive error handling

Here's the refactored version following your standards...
```

## Practical Examples

### Security Pattern Application

**Organization Pattern:**
> "All API endpoints must validate input using Joi schemas before processing"

**In Claude Code:**
```
You: "Create a user registration endpoint following our security patterns"

Claude Code: I can see your organization requires Joi validation for all API endpoints. Here's an implementation that follows that pattern:

[Shows code with proper Joi schema validation]

This follows your security pattern by validating all input parameters before processing. Should I also add rate limiting as per your other security patterns?
```

### Style Guide Enforcement

**Organization Pattern:**
> "Use async/await instead of Promise.then() for better readability"

**In Cursor:**
```
You: "Help me refactor this Promise-based code"

Cursor: Based on your organization's coding patterns, I'll convert this to use async/await for better readability:

[Shows before/after comparison following the pattern]

This change aligns with your organization's preference for async/await syntax.
```

### Architecture Pattern Guidance

**Organization Pattern:**
> "Always use React hooks instead of class components"

**Resolution Workflow:**
```
You: "I need to create a component that manages form state"

IDE: Your organization prefers React hooks over class components. Here's a functional component using useState and useEffect:

[Shows hook-based component implementation]

This follows your architectural pattern for React development.
```

## Advanced Workflows

<Note>
The following sections cover advanced automation. For basic pattern usage, the steps above are sufficient.
</Note>

### Creating New Patterns

**From Code Review Feedback:**
```
You: "Create a new coding pattern based on this recent review feedback: 'Always use TypeScript strict mode for new services'"

Claude: I'll create a new custom context pattern for you:

Pattern Type: CUSTOM_INSTRUCTION
Body: "Always use TypeScript strict mode for new services to catch potential errors at compile time"
Scope: Apply to **/services/**/*.ts files

This pattern will help ensure consistent TypeScript configuration across your service layer. Should I create this pattern?
```

**From Common Code Issues:**
```
You: "We keep having issues with database connection leaks. Create a pattern to prevent this"

Claude: Based on common database patterns, I'll create a custom context entry:

Pattern: "Always use connection.close() or connection.end() in finally blocks when working with database connections"
Scope: Database-related files (**/db/**/*.js, **/models/**/*.js)

This pattern will remind developers to properly clean up database connections.
```

### Team Onboarding

**New Developer Setup:**
```
You: "Show a new team member all our coding patterns and explain why we use them"

Claude: Here are your organization's key coding patterns:

1. **Security Pattern**: "Validate all API inputs using Joi schemas"
   - Why: Prevents injection attacks and ensures data integrity
   - Applied to: All API route files

2. **Style Pattern**: "Use async/await instead of Promise.then()"
   - Why: Better readability and error handling
   - Applied to: All JavaScript/TypeScript files

3. **Architecture Pattern**: "Prefer composition over inheritance"
   - Why: More flexible and testable code
   - Applied to: Class-based components

[Continues with all patterns and explanations]
```

### Pattern Evolution

**Update Patterns Based on Usage:**
```
You: "How effective is our async/await pattern? Should we update it?"

Claude: Analyzing your async/await pattern usage:

- Pattern triggered in 45 code reviews
- 89% compliance rate
- Most violations in legacy files (**/legacy/**/*.js)
- Recent trend shows improving adoption

Recommendation: Pattern is effective. Consider updating scope to exclude legacy files where migration isn't planned.
```

---

## Best Practices

<Accordion title="Quick Reference: When to Use Different Pattern Types">

### When to Use Custom Instructions
- Coding style preferences ("Use camelCase for variables")
- Framework usage guidelines ("Prefer hooks over class components")
- Security requirements ("Always validate user input")

### When to Use Patterns
- Architecture decisions ("Use microservices for new features")
- Design principles ("Favor composition over inheritance")
- Code organization rules ("Group related functions in modules")

### Pattern Effectiveness Tips
- **Be specific**: "Use Joi for API validation" vs "Validate inputs"
- **Include context**: Explain why the pattern exists
- **Scope appropriately**: Apply patterns to relevant file types only
- **Keep current**: Update patterns as practices evolve

### Human Oversight
- **Review auto-suggestions**: Verify AI-generated code follows patterns correctly
- **Update regularly**: Keep patterns current with evolving best practices
- **Monitor usage**: Track which patterns are most/least effective
- **Team alignment**: Ensure all team members understand pattern reasoning

</Accordion>
